grammar Parsimon
  rule program
    ((space+ expression*) / expression*) space* <Program> {
      def before(env)
        env.push(:expressions, [])
      end
      def after(env)
        @expressions = env.pop(:expressions)
      end
    }
  end

  rule expression
    exp1 space*
  end
  rule exp1
    binary / exp2
  end
  rule exp2
    record_declaration
    / function_declaration
    / string_literal
    / numeric_literal
    / parentheses
    / reference
  end

  rule binary
    exp2 space* (
      '==' / '!=' / '=' / '+'
      / '*' / '-' / '/' / '%'
      / '&&' / '&' / '||' / '|'
    ) space* expression {
      def before(env)
        env.push(:expressions, [])
      end
      def after(env)
        left, right = env.pop(:expressions)
        env.peek(:expressions) << {
          :type => :binary,
          :operator => elements.drop(1).select { |e| e.text_value.strip() != '' }.first.text_value,
          :left => left,
          :right => right
        }
      end
    }
  end
  rule record_declaration
    "record" space* '{' space* (record_field space* (',' space* record_field space*)*)? '}' {
      def before(env)
        env.push(:fields, [])
      end
      def after(env)
        fields = env.pop(:fields)
        env.peek(:expressions) << {
          :type => :record_declaration,
          :fields => fields
        }
      end
    }
  end
  rule record_field
    variable_identifier (space* type_identifier)? {
      def after(env)
        env.peek(:fields) << {
          :name => elements.first.text_value,
          :type => if elements.size > 1 && elements.last.elements
            elements.last.elements.last.text_value
          else
            nil
          end
        }
      end
    }
  end
  rule function_declaration
    "func" space* '(' space* function_parameters? space* ')' space* '{' space* function_body '}' {
      def before(env)
        env.push(:expressions, [])
      end
      def after(env)
        exps = env.pop(:expressions)
        pp exps
        env.peek(:expressions) << {
          :type => :function_declaration,
          :parameters => exps.size == 1 ? [] : exps[0],
          :body => exps.size == 1 ? exps[0] : exps[1]
        }
      end
    }
  end
  rule function_parameters
    reference space* (',' space* reference)* {
      def before(env)
        env.push(:expressions, [])
      end
      def after(env)
        exps = env.pop(:expressions)
        pp exps
        env.peek(:expressions) << {
          :type => :function_parameters,
          :expressions => exps
        }
      end
    }
  end
  rule function_body
    expression* {
      def before(env)
        env.push(:expressions, [])
      end
      def after(env)
        exps = env.pop(:expressions)
        env.peek(:expressions) << {
          :type => :function_body,
          :expressions => exps
        }
      end
    }
  end
  rule numeric_literal
    ([1-9] [0-9]* / '0') {
      def after(env)
        env.peek(:expressions) << {
          :type => :numeric_literal,
          :value => text_value
        }
      end
    }
  end
  rule string_literal
    '"' ((!'"' .) / '\\"')* '"' {
      def after(env)
        env.peek(:expressions) << {
          :type => :string_literal,
          :value => text_value
        }
      end
    }
  end
  rule parentheses
    '(' space* expression space* ')'
  end
  rule reference
    identifier {
      def after(env)
        env.peek(:expressions) << {
          :type => :reference,
          :value => text_value
        }
      end
    }
  end

  rule identifier
    type_identifier / variable_identifier
  end
  rule type_identifier
    '^'* [A-Z] [a-zA-Z0-9_]*
  end
  rule variable_identifier
    [a-z] [a-zA-Z0-9_]*
  end

  rule space
    [ \t\n\r]
  end
end