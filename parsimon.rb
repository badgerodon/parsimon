# Autogenerated from a Treetop grammar. Edits may be lost.


module Parsimon
  include Treetop::Runtime

  def root
    @root ||= :program
  end

  module Program0
    def block
      elements[1]
    end
  end

  module Program1
  end

  module Program2
    def before(env)
      env.push(:blocks, [])
    end
    def after(env)
      @block = env.pop(:blocks).first
    end
  end

  def _nt_program
    start_index = index
    if node_cache[:program].has_key?(index)
      cached = node_cache[:program][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    i2, s2 = index, []
    s3, i3 = [], index
    loop do
      r4 = _nt_space
      if r4
        s3 << r4
      else
        break
      end
    end
    if s3.empty?
      @index = i3
      r3 = nil
    else
      r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
    end
    s2 << r3
    if r3
      r5 = _nt_block
      s2 << r5
    end
    if s2.last
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      r2.extend(Program0)
    else
      @index = i2
      r2 = nil
    end
    if r2
      r1 = r2
    else
      r6 = _nt_block
      if r6
        r1 = r6
      else
        @index = i1
        r1 = nil
      end
    end
    s0 << r1
    if r1
      s7, i7 = [], index
      loop do
        r8 = _nt_space
        if r8
          s7 << r8
        else
          break
        end
      end
      r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
      s0 << r7
    end
    if s0.last
      r0 = instantiate_node(Program,input, i0...index, s0)
      r0.extend(Program1)
      r0.extend(Program2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:program][start_index] = r0

    r0
  end

  module Block0
    def before(env)
      env.push(:statements, [])
    end
    def after(env)
      env.peek(:blocks) << {
        :statements => env.pop(:statements)
      }
    end
  end

  def _nt_block
    start_index = index
    if node_cache[:block].has_key?(index)
      cached = node_cache[:block][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_statement
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    r0.extend(Block0)

    node_cache[:block][start_index] = r0

    r0
  end

  def _nt_statement
    start_index = index
    if node_cache[:statement].has_key?(index)
      cached = node_cache[:statement][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_record_definition
    if r1
      r0 = r1
    else
      r2 = _nt_return_statement
      if r2
        r0 = r2
      else
        r3 = _nt_assignment
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:statement][start_index] = r0

    r0
  end

  module RecordDefinition0
    def record_definition_field
      elements[2]
    end
  end

  module RecordDefinition1
    def record_definition_field
      elements[0]
    end

  end

  module RecordDefinition2
    def type_identifier
      elements[2]
    end

  end

  module RecordDefinition3
    def before(env)
      env.push(:fields, [])
    end
    def after(env)
      env.peek(:statements) << {
        :type => :record_definition,
        :name => type_identifier.text_value,
        :fields => env.pop(:fields)
      }
    end
  end

  def _nt_record_definition
    start_index = index
    if node_cache[:record_definition].has_key?(index)
      cached = node_cache[:record_definition][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?("record", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("record")
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_space
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      s0 << r2
      if r2
        r4 = _nt_type_identifier
        s0 << r4
        if r4
          s5, i5 = [], index
          loop do
            r6 = _nt_space
            if r6
              s5 << r6
            else
              break
            end
          end
          if s5.empty?
            @index = i5
            r5 = nil
          else
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          end
          s0 << r5
          if r5
            if has_terminal?('{', false, index)
              r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('{')
              r7 = nil
            end
            s0 << r7
            if r7
              s8, i8 = [], index
              loop do
                r9 = _nt_space
                if r9
                  s8 << r9
                else
                  break
                end
              end
              r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
              s0 << r8
              if r8
                i11, s11 = index, []
                r12 = _nt_record_definition_field
                s11 << r12
                if r12
                  s13, i13 = [], index
                  loop do
                    i14, s14 = index, []
                    if has_terminal?(',', false, index)
                      r15 = instantiate_node(SyntaxNode,input, index...(index + 1))
                      @index += 1
                    else
                      terminal_parse_failure(',')
                      r15 = nil
                    end
                    s14 << r15
                    if r15
                      s16, i16 = [], index
                      loop do
                        r17 = _nt_space
                        if r17
                          s16 << r17
                        else
                          break
                        end
                      end
                      r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
                      s14 << r16
                      if r16
                        r18 = _nt_record_definition_field
                        s14 << r18
                      end
                    end
                    if s14.last
                      r14 = instantiate_node(SyntaxNode,input, i14...index, s14)
                      r14.extend(RecordDefinition0)
                    else
                      @index = i14
                      r14 = nil
                    end
                    if r14
                      s13 << r14
                    else
                      break
                    end
                  end
                  r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
                  s11 << r13
                end
                if s11.last
                  r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
                  r11.extend(RecordDefinition1)
                else
                  @index = i11
                  r11 = nil
                end
                if r11
                  r10 = r11
                else
                  r10 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r10
                if r10
                  if has_terminal?('}', false, index)
                    r19 = instantiate_node(SyntaxNode,input, index...(index + 1))
                    @index += 1
                  else
                    terminal_parse_failure('}')
                    r19 = nil
                  end
                  s0 << r19
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(RecordDefinition2)
      r0.extend(RecordDefinition3)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:record_definition][start_index] = r0

    r0
  end

  module RecordDefinitionField0
    def type_definition
      elements[1]
    end
  end

  module RecordDefinitionField1
    def variable_identifier
      elements[0]
    end

  end

  module RecordDefinitionField2
    def before(env)
      env.push(:type_definitions, [])
    end
    def after(env)
      env.peek(:fields) << {
        :name => variable_identifier.text_value,
        :type => env.pop(:type_definitions).first || 'Value'
      }
    end
  end

  def _nt_record_definition_field
    start_index = index
    if node_cache[:record_definition_field].has_key?(index)
      cached = node_cache[:record_definition_field][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_variable_identifier
    s0 << r1
    if r1
      i3, s3 = index, []
      s4, i4 = [], index
      loop do
        r5 = _nt_space
        if r5
          s4 << r5
        else
          break
        end
      end
      if s4.empty?
        @index = i4
        r4 = nil
      else
        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
      end
      s3 << r4
      if r4
        r6 = _nt_type_definition
        s3 << r6
      end
      if s3.last
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        r3.extend(RecordDefinitionField0)
      else
        @index = i3
        r3 = nil
      end
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        s7, i7 = [], index
        loop do
          r8 = _nt_space
          if r8
            s7 << r8
          else
            break
          end
        end
        r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
        s0 << r7
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(RecordDefinitionField1)
      r0.extend(RecordDefinitionField2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:record_definition_field][start_index] = r0

    r0
  end

  module ReturnStatement0
    def expression
      elements[2]
    end

  end

  module ReturnStatement1
    def before(env)
      env.push(:expressions, [])
    end
    def after(env)
      env.peek(:statements) << {
        :type => :return,
        :expression => env.pop(:expressions).first
      }
    end
  end

  def _nt_return_statement
    start_index = index
    if node_cache[:return_statement].has_key?(index)
      cached = node_cache[:return_statement][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('ret', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure('ret')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_space
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      s0 << r2
      if r2
        r4 = _nt_expression
        s0 << r4
        if r4
          s5, i5 = [], index
          loop do
            r6 = _nt_space
            if r6
              s5 << r6
            else
              break
            end
          end
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(ReturnStatement0)
      r0.extend(ReturnStatement1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:return_statement][start_index] = r0

    r0
  end

  module Assignment0
    def type_identifier
      elements[0]
    end

  end

  module Assignment1
    def variable_identifier
      elements[1]
    end

    def expression
      elements[5]
    end

  end

  module Assignment2
    def before(env)
      env.push(:expressions, [])
    end
    def after(env)
      env.peek(:statements) << {
        :type => :assignment,
        :namespace => if elements[0] == variable_identifier
          []
        else
          elements[0].elements.select { |x| x.text_value != '.' }.map { |x| x.text_value }
        end,
        :name => variable_identifier.text_value,
        :expression => env.pop(:expressions).first
      }
    end
  end

  def _nt_assignment
    start_index = index
    if node_cache[:assignment].has_key?(index)
      cached = node_cache[:assignment][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      i2, s2 = index, []
      r3 = _nt_type_identifier
      s2 << r3
      if r3
        if has_terminal?('.', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('.')
          r4 = nil
        end
        s2 << r4
      end
      if s2.last
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        r2.extend(Assignment0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        s1 << r2
      else
        break
      end
    end
    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    s0 << r1
    if r1
      r5 = _nt_variable_identifier
      s0 << r5
      if r5
        s6, i6 = [], index
        loop do
          r7 = _nt_space
          if r7
            s6 << r7
          else
            break
          end
        end
        r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
        s0 << r6
        if r6
          if has_terminal?('=', false, index)
            r8 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure('=')
            r8 = nil
          end
          s0 << r8
          if r8
            s9, i9 = [], index
            loop do
              r10 = _nt_space
              if r10
                s9 << r10
              else
                break
              end
            end
            r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
            s0 << r9
            if r9
              r11 = _nt_expression
              s0 << r11
              if r11
                s12, i12 = [], index
                loop do
                  r13 = _nt_space
                  if r13
                    s12 << r13
                  else
                    break
                  end
                end
                r12 = instantiate_node(SyntaxNode,input, i12...index, s12)
                s0 << r12
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Assignment1)
      r0.extend(Assignment2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:assignment][start_index] = r0

    r0
  end

  def _nt_expression
    start_index = index
    if node_cache[:expression].has_key?(index)
      cached = node_cache[:expression][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_member_access

    node_cache[:expression][start_index] = r0

    r0
  end

  module MemberAccess0
    def member_access
      elements[1]
    end
  end

  module MemberAccess1
    def primary_expression
      elements[0]
    end

  end

  module MemberAccess2
    def before(env)
      env.push(:expressions, [])
    end
    def after(env)
      exps = env.pop(:expressions)
      if exps.size > 1
        env.peek(:expressions) << {
          :type => :member_access,
          :expressions => exps
        }
      else
        env.peek(:expressions) << exps[0]
      end
    end
  end

  def _nt_member_access
    start_index = index
    if node_cache[:member_access].has_key?(index)
      cached = node_cache[:member_access][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_primary_expression
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        if has_terminal?('.', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('.')
          r4 = nil
        end
        s3 << r4
        if r4
          r5 = _nt_member_access
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(MemberAccess0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(MemberAccess1)
      r0.extend(MemberAccess2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:member_access][start_index] = r0

    r0
  end

  def _nt_primary_expression
    start_index = index
    if node_cache[:primary_expression].has_key?(index)
      cached = node_cache[:primary_expression][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_function
    if r1
      r0 = r1
    else
      r2 = _nt_string_literal
      if r2
        r0 = r2
      else
        r3 = _nt_numeric_literal
        if r3
          r0 = r3
        else
          r4 = _nt_reference
          if r4
            r0 = r4
          else
            r5 = _nt_paren_expression
            if r5
              r0 = r5
            else
              @index = i0
              r0 = nil
            end
          end
        end
      end
    end

    node_cache[:primary_expression][start_index] = r0

    r0
  end

  module ParenExpression0
    def expression
      elements[2]
    end

  end

  module ParenExpression1
    def before(env)
      env.push(:expressions, [])
    end
    def after(env)
      exp = env.pop(:expressions).first
      env.peek(:expressions) << exp
    end
  end

  def _nt_paren_expression
    start_index = index
    if node_cache[:paren_expression].has_key?(index)
      cached = node_cache[:paren_expression][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('(', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('(')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_space
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        r4 = _nt_expression
        s0 << r4
        if r4
          s5, i5 = [], index
          loop do
            r6 = _nt_space
            if r6
              s5 << r6
            else
              break
            end
          end
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          s0 << r5
          if r5
            if has_terminal?(')', false, index)
              r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure(')')
              r7 = nil
            end
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(ParenExpression0)
      r0.extend(ParenExpression1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:paren_expression][start_index] = r0

    r0
  end

  module Reference0
    def after(env)
      env.peek(:expressions) << {
        :type => :reference,
        :name => text_value
      }
    end
  end

  def _nt_reference
    start_index = index
    if node_cache[:reference].has_key?(index)
      cached = node_cache[:reference][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_type_identifier
    if r1
      r0 = r1
    else
      r2 = _nt_variable_identifier
      r2.extend(Reference0)
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:reference][start_index] = r0

    r0
  end

  module Function0
    def block
      elements[6]
    end

  end

  module Function1
    def before(env)
      env.push(:blocks, [])
    end
    def after(env)
      env.peek(:expressions) << {
        :type => :function,
        :block => env.pop(:blocks).first
      }
    end
  end

  def _nt_function
    start_index = index
    if node_cache[:function].has_key?(index)
      cached = node_cache[:function][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('func(', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure('func(')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_space
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        if has_terminal?(')', false, index)
          r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(')')
          r4 = nil
        end
        s0 << r4
        if r4
          s5, i5 = [], index
          loop do
            r6 = _nt_space
            if r6
              s5 << r6
            else
              break
            end
          end
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          s0 << r5
          if r5
            if has_terminal?('{', false, index)
              r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('{')
              r7 = nil
            end
            s0 << r7
            if r7
              s8, i8 = [], index
              loop do
                r9 = _nt_space
                if r9
                  s8 << r9
                else
                  break
                end
              end
              r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
              s0 << r8
              if r8
                r10 = _nt_block
                s0 << r10
                if r10
                  if has_terminal?('}', false, index)
                    r11 = instantiate_node(SyntaxNode,input, index...(index + 1))
                    @index += 1
                  else
                    terminal_parse_failure('}')
                    r11 = nil
                  end
                  s0 << r11
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Function0)
      r0.extend(Function1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:function][start_index] = r0

    r0
  end

  module NumericLiteral0
  end

  module NumericLiteral1
    def after(env)
      env.peek(:expressions) << {
        :type => :numeric_literal,
        :value => text_value
      }
    end
  end

  def _nt_numeric_literal
    start_index = index
    if node_cache[:numeric_literal].has_key?(index)
      cached = node_cache[:numeric_literal][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    if has_terminal?('\G[1-9]', true, index)
      r2 = true
      @index += 1
    else
      r2 = nil
    end
    s1 << r2
    if r2
      s3, i3 = [], index
      loop do
        if has_terminal?('\G[0-9]', true, index)
          r4 = true
          @index += 1
        else
          r4 = nil
        end
        if r4
          s3 << r4
        else
          break
        end
      end
      r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      s1 << r3
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(NumericLiteral0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
      r0.extend(NumericLiteral1)
    else
      if has_terminal?('0', false, index)
        r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('0')
        r5 = nil
      end
      if r5
        r0 = r5
        r0.extend(NumericLiteral1)
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:numeric_literal][start_index] = r0

    r0
  end

  module StringLiteral0
  end

  module StringLiteral1
  end

  module StringLiteral2
    def after(env)
      env.peek(:expressions) << {
        :type => :string_literal,
        :value => text_value
      }
    end
  end

  def _nt_string_literal
    start_index = index
    if node_cache[:string_literal].has_key?(index)
      cached = node_cache[:string_literal][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('"', false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('"')
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3 = index
        i4, s4 = index, []
        i5 = index
        if has_terminal?('"', false, index)
          r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('"')
          r6 = nil
        end
        if r6
          r5 = nil
        else
          @index = i5
          r5 = instantiate_node(SyntaxNode,input, index...index)
        end
        s4 << r5
        if r5
          if index < input_length
            r7 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure("any character")
            r7 = nil
          end
          s4 << r7
        end
        if s4.last
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
          r4.extend(StringLiteral0)
        else
          @index = i4
          r4 = nil
        end
        if r4
          r3 = r4
        else
          if has_terminal?('\\"', false, index)
            r8 = instantiate_node(SyntaxNode,input, index...(index + 2))
            @index += 2
          else
            terminal_parse_failure('\\"')
            r8 = nil
          end
          if r8
            r3 = r8
          else
            @index = i3
            r3 = nil
          end
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        if has_terminal?('"', false, index)
          r9 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('"')
          r9 = nil
        end
        s0 << r9
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(StringLiteral1)
      r0.extend(StringLiteral2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:string_literal][start_index] = r0

    r0
  end

  module TypeDefinition0
    def type_identifier
      elements[1]
    end
  end

  module TypeDefinition1
    def after(env)
      env.peek(:type_definition) << text_value
    end
  end

  def _nt_type_definition
    start_index = index
    if node_cache[:type_definition].has_key?(index)
      cached = node_cache[:type_definition][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    if has_terminal?('^', false, index)
      r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('^')
      r2 = nil
    end
    s1 << r2
    if r2
      r3 = _nt_type_identifier
      s1 << r3
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(TypeDefinition0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
      r0.extend(TypeDefinition1)
    else
      r4 = _nt_type_identifier
      if r4
        r0 = r4
        r0.extend(TypeDefinition1)
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:type_definition][start_index] = r0

    r0
  end

  module TypeIdentifier0
  end

  def _nt_type_identifier
    start_index = index
    if node_cache[:type_identifier].has_key?(index)
      cached = node_cache[:type_identifier][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('\G[A-Z]', true, index)
      r1 = true
      @index += 1
    else
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        if has_terminal?('\G[a-zA-Z0-9_]', true, index)
          r3 = true
          @index += 1
        else
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(TypeIdentifier0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:type_identifier][start_index] = r0

    r0
  end

  module VariableIdentifier0
  end

  def _nt_variable_identifier
    start_index = index
    if node_cache[:variable_identifier].has_key?(index)
      cached = node_cache[:variable_identifier][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?('\G[a-z]', true, index)
      r1 = true
      @index += 1
    else
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        if has_terminal?('\G[a-zA-Z0-9_]', true, index)
          r3 = true
          @index += 1
        else
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(VariableIdentifier0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:variable_identifier][start_index] = r0

    r0
  end

  def _nt_space
    start_index = index
    if node_cache[:space].has_key?(index)
      cached = node_cache[:space][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('\G[ \\t\\n\\r]', true, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      r0 = nil
    end

    node_cache[:space][start_index] = r0

    r0
  end

end

class ParsimonParser < Treetop::Runtime::CompiledParser
  include Parsimon
end
